#~~/scripts/ = /storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/ 
# include          = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/fonts.conf"       
#include          = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/input.conf"  
 # 该参数用于追加读取额外的设置文件。原配置预设组已被分离到该文件中
 use-filedir-conf = yes                      
 # 允许使用特定文件的设置文件 https://mpv.io/manual/master/#file-specific-configuration-files
#sub-fonts-dir="/storage/emulated/0/Fonts"
#
sub-fonts-dir="/storage/3335-3432/Download/zdownload/[ANK-Raws] Little Busters! (BDrip 1920x1080 HEVC-YUV420P10 FLAC SUP)/fonts"
sub-fonts-dir="/storage/3335-3432/Download/zdownload/[VCB-Studio] Gekijouban Violet Evergarden/[VCB-Studio] Gekijouban Violet Evergarden [Ma10p_2160p]/[subbers] Violet Evergarden [Fonts]"
sub-fonts-dir="/storage/3335-3432/Download/zdownload/[VCB-Studio] Yuru Camp/[Airota&Nekomoe kissaten&VCB-Studio] Yuru Camp Movie [Ma10p_2160p]/[Airota&Nekomoe kissaten&VCB-Studio] Yuru Camp Movie [Fonts]"
#加载字体，详情参见https://www.coolapk1s.com/feed/51695659
log-file         = "~~/mpv-lazy.log" 
# 记录名为"mpv-lazy"的log日志在/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/mpv-lazy.log


 ########
 # 特殊 #
 ########
 
 
#image-display-duration=inf
#如果当前文件是图像，播放图像的时间为给定的秒数（默认： 1）。 inf 表示该文件永远保持打开（直到用户手动停止播放）。


  ####杜比视界（测试中）
  
#vf=format:dolbyvision=yes
#确保你播放的视频文件实际上包含 Dolby Vision 元数据时启用，且Dolby Vision 的正确渲染可能需要特定的硬件支持和软件编解码器，确保你的设备和 reex 的 libmpv 版本支持 Dolby Vision。
#为了避免不必要的资源消耗和潜在的兼容性问题，建议仅在需要播放 Dolby Vision 内容时临时启用该选项。by ChatGPT-4o
#vo                 = gpu-next
#mpv.conf读取命令是以最后的为准，故请到下面的基础调整，此处删去注释也没用
#hwdec              = no
#一般来说只能软解播放，hwdec = mediacodec-copy和mediacodec会绿屏
#也是同上，请到下面的基础调整
#865软解dolbyvision效率感人，有这个需求还是用电脑看吧，不要为难865了


#keepaspect=no
#keepaspect=no会始终将视频拉伸到窗口大小，并禁用窗口管理器的提示的窗口强制长宽比。（在全屏模式下被忽略）
#不用管



 ##############
 # 性能测试选项 #
 ##############
 
 
#osd-msg1      = "FPS: ${estimated-display-fps}"
#OSD显示当前每秒的极限输出帧数
#video-sync=display-desync
#同步视频到显示，并让音频自行播放。
#untimed=yes
#立即输出捕获的帧，而不是遵循输入的帧速率



 ########
 # 基础 #
 ########


 vo                 = gpu 
# vo                 = gpu-next
#vo = mediacodec_embed      
# <默认gpu|gpu-next|mediacodec_embed> 视频输出驱动。许多渲染相关的选项也只能在前两项下正常工作。当前版本首选gpu。解码杜比视界时需指定为gpu-next
#android平台使用 mediacodec_embed 时, 效率最高且只使用本机解码渲染, 无法使用特殊滤镜与着色器。

# gpu最高普适性和完成度；gpu-next查看此处讨论 https://github.com/hooke007/MPV_lazy/discussions/39
                                     
                                                
 #gpu-context        =opengl
 gpu-context        = android
 # <win|d3d11|winvk|android> 选择图形输出后端，默认 auto（此项的值与 --gpu-api=<opengl|d3d11|vulkan> 相对应）
#android平台使用vo=gpu时, 此项应为android
#值为opengl会黑屏

  gpu-api=opengl
#gpu-api=vulkan
 ### gpu-api的选择？
## macOS：  只有opengl可选
## Linux：  vulkan或者opengl，推荐vulkan
## Windows：vulkan、d3d11及opengl都可选。三者理论上vulkan性能最好，但依然推荐d3d11。
## 通过d3d11 api，目前mpv已支持windows的10 bit输出和HDR colorspace的设定。
## HDR metadata pass on正在跟进，独占全屏正在跟进。
#android平台为保证兼容性推荐opengl，指定为 vulkan 会回退为 opengl
#----------------------------------------

hwdec              = mediacodec-copy      
#hwdec              = mediacodec
# hwdec              = no

 # 指定应使用的硬件视频解码API，默认软解（no）。
#Android平台要使用硬解码应使用 --vo=gpu ，并一起使用 --hwdec=mediacodec 或 --hwdec=mediacodec-copy 和 --gpu-context=android
#Android平台效率最高的硬解为 mediacodec 但它强制进行RGB转换（非 -copy ），它对非标准色彩空间的处理效果如何还不清楚。在极少数支持10位的情况下，输出的位深度将被降低到8。
#为保证硬解兼容性最好和正常使用滤镜与着色器，请使用 mediacodec-copy 即将视频复制回到系统RAM（Android独占）

#wid=android.view.Surface
#窗口为*android.view.Surface
#(intptr_t)(*android.view.Surface)

--opengl-swapinterval=1
#两次缓冲区互换之间的显示帧间隔。1相当于启用垂直同步，0相当于禁用垂直同步。如果没有指定则默认为1。

#--android-surface-size=1080×1920
#设置Android gpu上下文使用的渲染表面的尺寸。如果尺寸在运行期间发生变化（例如，如果设备被旋转），需要由嵌入的应用程序通过surfaceChanged回调进行设置。
#（Android 和 --gpu-context=android 独占）

 vd-lavc-software-fallback=3
#如果硬件加速解码器失败，退回到软件解码（默认：3）<yes|no|N>
#如果这是一个数字，那么如果连续N个帧解码失败，就会触发回退。1相当于 yes

 vd-lavc-dr=yes
#启用直接渲染（默认： yes）<yes|no>
#如果设置为 yes ，视频将被直接解码到GPU video memory（或暂存缓冲区）。这可以加快视频上传速度，对高分辨率或慢速硬件可能有帮助。这只适用于以下的视频输出驱动：
#gpu : 需要至少OpenGL 4.4或Vulkan
#libmpv : libmpv渲染API有可选的支持
# <默认yes|no> 是否直接解码到显存，个别低端英特尔处理器需要禁用此功能以大幅提速解码
#高通系芯片可能没有显存，建议为no

 vd-lavc-threads=16
#解码时使用的线程数
#建议在4K视频上采用较高的线程数
#实际是否支持线程取决于编码（默认： 0）<N>，0表示自动检测机器上的核心数并使用该数，最多为16。你可以手动设置16个以上的线程。
#经测试值为16时可能提升每秒两帧，也可能无影响

fbo-format         = rgba16f        
#fbo-format         = rgba32        
# 内处理精度。此项通常由 --gpu-api 或 --gpu-context 自动决定正确值，默认首选16位及以上的精度<rgba16/rgba16f/rgba32>
#选择用于FBOs的纹理的内部格式。该格式可以影响视频输出的性能和质量。可以是：rgb8, rgb10, rgb10_a2, rgb16, rgb16f, rgb32f, rgba12, rgba16, rgba16f, rgba16hf, rgba32f之一。

#默认： auto ，首先尝试使用16位浮点（rgba16f, rgba16hf），如果没有这些浮点，则回退到rgba16。最后，如果先前的所有格式都不可用，则尝试使用rgb10_a2或rgba8。

hwdec-codecs       = h264,vc1,hevc
# 在选定范围内的编码格式尝试硬解，当前版本默认值为 "h264,vc1,hevc,vp8,vp9,av1,prores"

opengl-pbo = yes
#启用PBOs。opengl 3.0及以上启用。在某些驱动上，这可能会更快，特别是当源视频尺寸很大时（例如所谓的“4K”视频）。在其他它驱动上，它可能会更慢或引起延迟问题。

demuxer-thread=yes
#在一个单独的线程中运行解复用器，并让它预取一定数量的packets（默认： yes）。启用这个功能可以使播放更顺畅，启用预取等功能，并防止网络卡住使播放器冻结。另一方面，它可能会增加开销，或者后台预取会占用CPU资源。


 ########
 # 功能 #
 ########

#background             = "#000000"   
# <格式为(AA)RRGGBB> 更改MPV初启动与播放无视频轨文件时的背景颜色，会影响视频播放时的背景。
 pause                  = no         
 # 以暂停状态启动播放器
#panscan                = 1.0         
# <0.0-1.0> 裁切横向画面以充满窗口（建议配合 keepaspect-window=no 使用）
loop                   = no        
# <N|inf|默认no> 始终循环播放当前文件
loop-playlist          = yes          
# <N|inf|force|默认no> 播放列表循环
 hr-seek-framedrop      = no          
 # [SVP补帧时推荐设置为no] 跳转时丢帧，关闭利于修正音频延迟
# 
save-position-on-quit  = yes         
 # 退出时记住播放状态
 watch-later-options    = vid,aid,sid
# [SVP补帧时推荐设置为留空] 稍后观看的白名单（留空即只保存播放位置）;
# 当 --save-position-on-quit=yes 或使用退出时保存到稍后观看的功能时，如果不使用白名单，滤镜列表、音量、速率等其它状态也会被保存并在下次启动时恢复

##⇘⇘窗口相关
##此处已精简，详细说明与更多自定义参数请查看： https://github.com/hooke007/MPV_lazy/discussions/69

fs                     = yes         
# --fs 等效 --fullscreen。运行MPV自动进入全屏
 keep-open              = no         
 # <yes|默认no|always> 默认为播完列表不暂停，值为 yes 播完列表暂停，值为 always 时每个文件播完都暂停
#ontop                  = yes         
# 窗口置顶（当 --gpu-api=vulkan 时附带全屏独占的功能）。可选择性的启用配置预设 ontop_playback
#border                 = no          
# 默认为系统原生窗口界面，启用此项使用无边框界面（去除WINDOWS的窗口装饰）
#geometry               = 100%×100%    
# 设定初始位置或尺寸，附带锁定窗口比例的作用。支持多种表示方法（1280×720例 50%x50% 即桌面长宽的一半）
                                      
# 使用这项参数将无效化以下选项 --autofit --autofit-larger --autofit-smaller --window-scale
#autofit-larger         = 80%x80%     
# 窗口自动拉伸时（初起动/切换文件）防止太大。使用 --autofit 系列的参数将无效化 --window-scale
# autofit-smaller        = 40%x40%     
 # 窗口自动拉伸时（初起动/切换文件）防止太小
#keepaspect-window      = no          
# 窗口自由拉伸（no）还是按比例拉伸（默认 yes）
 hidpi-window-scale     = no          
 # <默认yes|no> 是否执行HIDPI缩放（推荐禁用，原因是会影响 --window-scale 的真实数值）


##⇘⇘缓存相关

cache=no
#
cache=yes
#--cache=<yes|no|auto>
#决定是否使用网络缓存设置（默认： auto）。
cache-secs=60	
#cache-secs=<seconds>
#如果缓存被激活，要预读取多少秒的音频/视频。
cache-on-disk=yes
#cache-on-disk=<yes|no>
#cache-on-disk=no
#将packet数据写入到一个临时文件，而不是将它们保存在内存中。这只有和 --cache 一起使用才有意义。如果一般的缓存被禁用，这个选项将被忽略。
#你需要设置 --cache-dir 来使用它。
cache-pause=yes
#cache-pause=<yes|no>
#当缓存中的数据用完后，播放器是否应该自动暂停，又名“缓冲”，并中止解码/播放（默认： yes）。如果启用，它会暂停，一旦有更多的数据可用，就解除暂停。
cache-pause-wait=1
#cache-pause-wait=<seconds>
#如果输入了“缓冲”，packet缓存在再次开始播放之前应该有多少秒的缓冲时间（默认： 1）。这可以用来控制如果 --cache-pause 被启用，解复用器拖欠时，播放器重新缓存的时间。如果给定的时间高于 --cache-secs 或 --demuxer-readahead-secs 设置的最大时间，或者由于其它原因（如文件结束或达到设置的最大缓存大小）预读取结束，播放将提前恢复。
cache-pause-initial=yes
#cache-pause-initial=<yes|no>
#在开始播放前进入“缓冲”模式（默认： no）。这可以用来确保播放顺利开始，以换取等待一些时间来预读取网络数据（由 --cache-pause-wait 控制）。例如，一些常见的行为是，播放开始后，但随着播放的进行尝试解码更多的数据时，网络缓存立即不足。
demuxer-max-bytes      = 2048MiB      
# 播放网络视频时的向后缓存大小（KiB或MiB）
demuxer-max-back-bytes=768MiB
# 向前缓存大小

# 缓存

cache-dir="~~/_cache/"  
#--cache-dir=<path>
#创建临时文件的目录（默认： none）。
#目前，这只用于 --cache-on-disk
# icc-cache-dir          = "~~/_cache/icc"                                   
# 指定目录存储和加载从ICC配置文件创建的3D LUT，可以用来加快加载速度。未压缩的LUT的大小取决于 --icc-3dlut-size

 gpu-shader-cache-dir   = "~~/shaders/cache"                                   # 在此目录中存储和加载已编译的GLSL着色器缓存，可以提高启动性能
 
# watch-later-directory  = "~~/_cache/watch_later"
                                      
# 稍后观看功能的缓存目录，其中的文件记录 --watch-later-options 指定的选项。默认路径为 "~~/watch_later"



 #######
 # OSD #
 #######

##⇘⇘OSD 即 On-Screen-Display ，通常为屏幕上弹出显示的信息。 OSC 即 on-screen-controller ，MPV中指的是简易操控界面
##更多自定义查询 https://mpv.io/manual/master/#osd

 osd-on-seek              = msg-bar     
 # <no,bar,msg,msg-bar> 在跳转时间轴时显示的信息类型
 
 



#osd-blur                 = 0
# osd-bar-w                = 100
# osd-bar-h                = 1
 #osd-bar-align-y          = -1
   osd-color                = "#FFFFFF"
osd-border-color         = "#111111"
#OSD 边框颜色
# osd-border-size          = 1
 osd-font-size            = 50
 # 更改OSD字体大小（全局，影响多个功能显示的文本），默认 55
 osd-fractions            = yes         
 # 以秒为单位显示OSD时间（毫秒精度），有助于查看视频帧的确切时间戳
#
osd-playing-msg          = "${filename}"
# 每个文件开始播放时短暂显示的信息。预设显示文件名
 osd-duration             = 1500        
 # 设置（全局）OSD文本信息的持续时间（毫秒），默认 1000
 osd-playing-msg-duration = 4000        
 # --osd-playing-msg 文本的持续时间，如不设置此项，则使用全局持续时间
#     showonpause = yes,                
     # --在暂停时常驻 OSC|false
#    showonstart = yes,                
    #-- 在播放开始或当播放下一个文件时显示 OSC
#    showonseek = false,                 
    #-- 在跳转时显示 OSC

#统计信息
load-stats-overlay=yes
# 启用统计数据



 ########
 # 音频 #
 ########

audio-device           = auto
# 此项用于指定启动时的音频输出设备
                                 # 改具体值示例 --audio-device="wasapi/{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"，设备名获取方式见发布页FAQ图文或官方手册
audio-exclusive        = yes    
# 音频通道独占（如果有其他软件先独占音频通道后，再打开MPV可能会画面会卡顿）
#
volume                 = 100     
# 播放器启动音量。0为无，默认 100，与安卓平台音量冲突。
volume-max             = 130    
# <100.0-1000.0> 最大音量。默认 130（该响度约为100的两倍 1.3^3≈2）
 replaygain-preamp = 0
#预放大增益，单位为dB，应用于选定的回放增益（默认： 0）
#audio-delay=0
#音频延迟，以秒为单位（正或负的浮点值）。正值是延迟音频，负值是延迟视频（默认： 0）
#mute=no
#设置启动时的音频静音状态（默认： no）<yes|no|auto>
#audio-file-auto=<no|exact（加载带有音频文件扩展名的媒体文件名）|fuzzy|all>, --no-audio-file-auto
#加载与视频文件名匹配的额外音频文件。参数指定了外部音频文件的匹配模式。
#af-toggle=@audnorm:lavfi=[loudnorm=I=-16:TP=-3:LRA=4] 
#loudnorm
#af-toggle=@dynnorm:lavfi=[dynaudnorm=g=5:f=250:r=0.9:p=0.5]
#dynaudnorm
#调节各声道的增益, 可解决双通道下多声道音频下混时产生的背景音或人声过小的问题
audio-channels         = stereo 
#audio-channels         = mono
# 强制多声道音源下混为双声道输出（避免可能的7.1/5.1→2.0声音丢失和音量过小）
#scaletempo=scale=1.0:stride=60:overlap=.20:search=14:speed=tempo
#scaletempo2=min-speed=0.25:max-speed=4.0:search-interval=30:window-size=20
#rubberband
audio-pitch-correction = yes     
# 变速播放时的音调修正，默认 yes
alang                  = chs,sc,zh,chi,zho
                                 # 音轨首选语言为中文，但MPV优先加载外挂轨道，此项参数可能实际用处不大
 audio-file-auto        = exact  
 # <默认no|exact|fuzzy|all> 自动加载同名外挂音轨（fuzzy为模糊名，exact为精确名）




 ########
 # 视频 #
 ########
##⇘⇘色彩管理

#icc-profile-auto            = yes               
# 如果做过专业校色应开启（系统目录存在对应的icm校色文档）。未做校色的广色域屏应手动指定 --target-prim
#icc-profile                 = "X:/xxx/xxxx.icm"
# 此选项用于加载指定的ICC，与前项不共存
#icc-3dlut-size              = <r>x<g>x<b>       
# <2-512> 从ICC配置文件的每个维度生成的3D LUT的大小。默认 64x64x64
#icc-force-contrast          = no               
# <no|0-1000000|inf> 强制指定ICC的静态对比度而不是使用配置文件的内设（可能存在测量错误）。默认 no
# 普通LCD一般使用 1000（以面板原生数据为准）；使用OLED显示设备的用户尝试使用 1000000 或特殊值 inf

target-prim                 = auto              
# 当不使用ICC颜色管理时，视频颜色将适应此颜色空间
# 未经校色的广色域屏可设定此参数以解决色彩过饱和的问题。例如99%的argb屏幕写adobe。90%+的p3色域屏写dci-p3（srgb屏无需更改此默认值）
#HDR视频字幕出现时发生亮度变化禁用blend-subtitles




########
##⇘⇘音视频同步模式。只需注释掉 --video-sync 即可恢复MPV的默认同步模式
########




# video-sync                  =desync
#同步视频到系统时钟，并让音频自行播放。
# video-sync                  = audio
# 默认值 audio（与音频/系统时钟同步）通常兼容性最好但有偶尔的丢帧和重复
#将视频帧计时到音频。这是最稳健的模式，因为播放器不需要对显示器的行为进行任何假设。缺点是它可能会导致偶尔的丢帧或重复。如果音频被禁用，这将使用系统时钟。这是默认模式。

#video-sync                  = display-resample  
 #对音频重新采样以匹配视频。这种模式也将尝试调整音频速度来补偿其它漂移（这表示它将每隔一段时间以不同的速度播放音频，以减少A/V差异）。
 
#video-sync                  =display-resample-vdrop
#重新采样音频以匹配视频。丢弃视频帧以补偿漂移。

# video-sync                  =display-resample-desync
#与之前的模式一样，但没有A/V补偿。

# video-sync                  =display-vdrop
#丢弃或重复视频帧，以补偿不同步的视频（虽然它应该有与 audio 相同的效果，但实现却非常不同）。

# video-sync                  =display-adrop
#丢弃或重复音频数据以补偿不同步的视频。如果真实的显示器刷新率与报告的或强制的刷新率相差太大，这种模式将引起严重的音频瑕疵。从mpv0.33.0开始，这个模式作用于整全部音频帧，而不是单个采样。

# video-sync                  =display-desync
#同步视频到显示，并让音频自行播放。

                                                 

 video-sync-max-video-change = 1                 
 # [仅当 --video-sync=display-xxxx 时生效] 默认1
 #应用于 --video-sync=display-... 的视频的最大速度差，以百分比为单位（默认： 1）。如果显示器和视频刷新方式在给定范围内不匹配，显示同步模式将被禁用。它还会尝试倍数：在60赫兹的屏幕上播放30帧的视频，每隔一帧就会重复一次。在60赫兹的屏幕上播放24帧的视频将以2-3-2-3-…的模式播放视频。
#默认设置不够宽松，无法将23.976帧的视频加速到25帧。我们认为音调变化过于极端，默认情况下不允许这种行为。将这个选项设置为 5 的值来启用它。
#注意，在 --video-sync=display-resample 模式下，如果需要A/V同步，音频速度将额外被改变一点。
 interpolation               = no  
# interpolation               = yes             
 # [仅当 --video-sync=display-xxxx 时生效] 减少由于视频帧率fps和显示刷新率hz不匹配而引起的卡顿/抖动
 interpolation-threshold=0.01
#低于这个阈值的帧率将被禁用插值选项<0..1,-1>（默认： 0.01即1% ）。计算方法是 abs(disphz/vfps - 1) < threshold ，其中 vfps 是速度调整后的视频FPS， disphz 是显示器刷新率（速度调整后的视频FPS大致等于正常的视频FPS，但是应用了减速和加速。如果你使用 --video-sync=display-resample 来使视频与显示FPS同步运行，或者改变 speed 属性，这很重要）。

#默认的目的是，在使用 --video-sync=display-* 的重计时不能充分调整视频速度以实现流畅播放的情况下启用插值。例如，如果一个视频是60.00FPS，而你的显示器刷新率是59.94Hz，插值将永远不会被激活，因为不匹配是在刷新率的1%以内。默认值还处理了mpv不能确定容器FPS的情况，比如在某些直播流中，可能会动态地切换插值的开启和关闭。在这种情况下，默认情况是不使用插值，而是允许 --video-sync=display-* 来重新计时视频以匹配显示器的刷新率。详见 --video-sync-max-video-change 了解关于mpv如何重新计时视频。
#还要注意的是，如果你使用 --video-sync=display-vdrop ，速率的微小偏差会禁用插值，每隔一分钟就会引入一个不连续。
#将此设置为 -1 来禁用这个逻辑。

# interpolation-preserve = no
#即使渲染器参数发生变化，也保留前几帧的插值结果 —— 与剪切和视频放置有关的选项除外，这些选项总是会使缓存失效。启用该选项可以使渲染器设置的动态更新稍微平滑，但代价是对这种变化的响应延迟会稍高。默认为开启（只影响 --vo=gpu-next ，注意 -vo=gpu 始终使插值的帧失效）。

 tscale                      = mitchell            
 # [仅当 --interpolation=yes 时生效] 时间插值算法（帧混合，非光流法）
  #常见的 --tscale 选择包括 oversample, linear, catmull_rom, mitchell, gaussian, 或 bicubic 。这些都是按照平滑度/模糊度递增的顺序排列的， bicubic 是最平滑/最模糊的，而 oversample 是最清晰/最不平滑的。                                        
# 追求原始观感可以使用 oversample（效果类似MADVR的smoothmotion），默认 mitchell

 video-sync-max-factor=5
#尝试将视频的FPS与显示的FPS相匹配的最大倍数（默认： 5）
  framedrop=vo
#在速度慢的系统上，或者在有帧数上限的视频输出上播放高帧率的视频时，跳过显示一些帧来维持A/V同步。
        ###
#vf=frame-interpolation
#fps=120



#vf=vapoursynth="/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/vs/svpflow-std.vpy"
##⇘⇘“画质”相关
##避免简单粗暴的使用 --profile=gpu-hq ，原因见手册 [02]

#scale-radius               = 1.0
#可以用来控制半径。增加半径会使filter更锐利但会增加更多的振铃。<0.5-16.0>

#scaler-lut-size=9
#设置缩放器kernels的查找纹理的大小（默认： 6）。纹理的实际大小是 2^N ，选项值为 N <6——10>。查找纹理使用64、128、256、512、1024采样。
#所有的权重都是从这些采样中线性插值出来的，所以增加查找表的大小可能会改善缩放器的精度。

#csale                      = bilinear  
#cscale                      = spline64
#cscale                      =sinc
cscale                      = lanczos
#cscale                      = ewa_lanczos
#cscale                      = jinc
#cscale                      = ewa_lanczossharp
#glsl-shaders-append  = "~~/shaders/KrigBilateral.glsl"
#glsl-shaders-append  = "~~/shaders/CfL_Prediction.glsl"
#大概率蓝屏
# 色度还原算法；可由更好的 "KrigBilateral.glsl" 着色器取代。默认 bilinear/spline36/lanczos/ewa_lanczoss/ewa_lanczossharp/mitchell/oversample/linear
#cscale-cutoff=0.07
#一旦数值范围下降到这个阈值以下，就提前切断filter的kernel。这样做可以通过忽略LUT中被window函数有效归零的部分，更积极地修剪可跳过的系数。只影响polar (EWA) filter。默认是0.001，这在感知上是透明的，但可以提供10%-20%的加速，取决于所选择的确切半径和filter kernel。


scale                       = lanczos       
#scale                       = ewa_lanczos  
#该filter是 jinc-windowed jinc 的别名
#scale                       = ewa_lanczossharp  
 # 放大算法，默认值同上|catmull_rom, 推荐ewa_lanczossharp
 
#dscale                      =mitchell  
dscale                      =catmull_rom
#dscale                      =bilinear
#dscale                      =linear
# 缩小算法。若不设定，则自动采用 --scale 的值
##所有可用的内置算法参见手册 [06]
#推荐使用mitchell


#--scale-cutoff=<value>
#--cscale-cutoff=<value>
#--dscale-cutoff=<value>
#一旦数值范围下降到这个阈值以下，就提前切断filter的kernel。这样做可以通过忽略LUT中被window函数有效归零的部分，更积极地修剪可跳过的系数。只影响polar (EWA) filter。默认是0.001，这在感知上是透明的，但可以提供10%-20%的加速，取决于所选择的确切半径和filter kernel。

#--scale-antiring=<value>
#--cscale-antiring=<value>
#--dscale-antiring=<value>
#--tscale-antiring=<value>
#设置抗振铃强度。这尝试消除振铃，但在此过程中可能会引入其它伪影。必须是0.0和1.0之间的浮点数。默认值0.0完全禁用抗振铃。

sigmoid-upscaling           = yes                
 #放大时非线性的颜色转换，可避免强振铃伪影
 #当放大时，使用正弦波颜色变换以避免强调振铃伪影。
 linear-upscaling            = no            
#在放大时线性缩放亮度。   
# [须 --fbo-format 指定16位及以上的精度；与 --sigmoid-upscaling 不兼容] （对HDR内容无影响）
##开发者建议要么优先使用 --sigmoid-upscaling ，要么以上两项干脆都不用
linear-downscaling          = yes  
#linear-downscaling          =   no
#在缩小时线性缩放亮度。     
# [使用"SSimDownscaler.glsl"时须关闭；须 --fbo-format 指定16位及以上的精度] （对HDR内容无影响）
##上两项 --linear- 的参数对应MADVR中的"scale in linear light"，在缩小算法中线性处理可以提升颜色对比度的精确性
#glsl-shaders-append = "~~/shaders/SSimSuperRes.glsl"
#该着色器的目的是对mpv内置 --scale=xxxxx 放大算法进行增强校正。
#glsl-shaders-append = "~~/shaders/SSimDownscaler.glsl"
#基于感知的对mpv内置 --dscale=xxxxx 缩小算法进行增强校正。（例如抗振铃）仅当 mpv.conf 中设定 --linear-downscaling=no 时正常工作
#经测试不能正常工作

correct-downscaling         = yes               
# [当 --dscale=bilinear 时此项无效] 增强缩小算法的质量，对于异形比例视频可能产生微小失真

#scaler-resizes-only         = yes               
# 当未进行缩放处理时，使用bilinear算法完美还原。默认 yes
# 如果视频图像没有调整大小，则禁用缩放器。在这种情况下， bilinear 会被用来代替 --scale 设置的任何东西，即如果不进行缩放，双线性将完美再现源图像。默认启用。注意，这个选项不会影响 --cscale                                               
# 禁用时，即使未缩放，也使用 --scale 指定的算法处理。此时可修正nnedi3和ravu引入的半像素偏移（但没必要）


 dither-depth                =no
# dither-depth                = 10              
 # <N|no|auto> 是否开启色深抖动弥补色彩转换损失。8位显示器写8，10位显示器写10，auto的值取决于 --gpu-api 不一定正确                              
# 如果8抖10的显示器使用10存在输出异常的情况，改回值8
#dither                      = error-diffusion   
# <默认fruit|ordered|error-diffusion|no> 
#色深抖动的算法；值 no 等效 --dither-depth=no                                              # 误差扩散非常好但没必要，它基于计算着色器需要不低的性能开销，感知弱
#error-diffusion=burkes
#当设置了 --dither=error-diffusion 时，使用的误差扩散的kernel。
#不可用





#include          = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles.conf"
#老东西，已被下列文件拍死在沙滩上（笑）

include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/SD-ex_reality.conf"

include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/HD++.conf"

include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/FHD.conf"

include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/2K.conf"

#
include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/ScreenRecorder.conf"
#自用，用来修正录屏色域问题，更换解码方式以减少音画不同步的问题。主要加了下面两条命令
#hwdec              = mediacodec
#glsl-shaders-append  = "~~/shaders/colorprim_601_to_709.glsl"
#include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/self-adaptive_deband.conf"
#自适应去色带

#include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/BT601toBT709.conf"

#include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/VCB-Studio.conf"
#会与 osd-playing-msg          = "${filename}" 冲突，只显示“LittlePox : SAYA is a lolicon !!!”


#vf-append=minterpolate=fps=60

#fps=fps=60/1.001
#通过帧采样强制视频以指定帧率输出。示例可用于播放滚动弹幕时增强平滑性，此时分子数值（取整）为你的显示器刷新率
#https://ffmpeg.org/ffmpeg-filters.html#fps-1

#framerate=fps=60/1.001
#作用类似，区别是帧混合（线性插值）。
#https://ffmpeg.org/ffmpeg-all.html#framerate
#P.S. 此二项在效果上与补帧冲突。




#deband                      = yes               
# 去色带。可能受硬解码影响实际效果

#profile                     = DeBand+           
# 备选的去色带方案，具体参数见 "profiles.conf" 中的同名配置预设

#profile                     = deband_bitrate
#基于码率的自动去色带

#profile                     = FHD&2K
#1080&-2160P

#profile                     = HD++
#720P-1080P

#profile                     = SD-ex-reality
#>720P

#profile                     = Depand-0
#YUV420P10及以上的源关闭去色带
#老东西，不会影响视频播放，不用管




 ####################
 # 脚本 滤镜 着色器 #
 ####################

##以下都可选择在此处开启，即默认每次随播放器启动；或者使用"input.conf"中的方案手动选择加载

##⇘⇘脚本部分

##内置脚本开关（如果没有必要的目的，那就不要屏蔽mpv内建的功能）
#load-auto-profiles      = yes 

load-osd-console        = yes   
# 控制台
load-stats-overlay      = yes   
# 统计信息
# osc                     = no   
 # [使用第三方OSC的前置条件] 禁用原OSC（即内置的"osc.lua"脚本）以兼容第三方的界面样式
 
#ytdl                    = yes   
# 网址解析增强
#ytdl-raw-options-append = cookies=[D:/cookies.txt]
                                # [当 --ytdl=yes 时有效] 将自定义的选项传递给ytdl https://github.com/ytdl-org/youtube-dl#options
                                # 示例仅为传递单个选项，多个选项最好独立追加，即写多个 --ytdl-raw-options-append 参数 https://mpv.io/manual/master/#options-ytdl-raw-options

#load-scripts       = no        
# 自动挂载 /scripts/ 目录中的所有外置脚本，默认 yes。设置为no时可用下一行示例的命令加载指定的外置脚本
#scripts            = "~~/scripts/load_plus.lua;~~/scripts/playlistmanager.lua;~~/scripts/fix-avsync.lua;~~/scripts/drcbox.lua~~/scripts/osc_lazy.lua"
#不知 reex 或 libmpv 能否加载外置脚本，故注释掉

##⇘⇘滤镜部分
##设定随MPV启动的音/视频滤镜的书写格式（支持多项） --af/vf=滤镜①=参数❶=值:参数❷=值,滤镜②...
## --af 和 --vf 仅能各存在一条。如果不想只使用这条参数，可以拆开写，例如使用 --vf-append 单项多次追加更多的滤镜，并不会覆盖 --vf 指定的滤镜
##更多实用向的滤镜可参考 https://github.com/hooke007/MPV_lazy/discussions/120
#vf=format=fmt=yuv420p10le
#vf-append = format=gamma=pq
#vf-append = format=gamma=hlg
#
vf-append = format=gamma=gamma2.2
# MPV校色曲线目标是BT.1886，此视频滤镜用于回归常见的显示器标准 https://github.com/mpv-player/mpv/issues/8009
#<auto|bt.1886|srgb|linear|gamma1.8|gamma2.0|gamma2.2|gamma2.4|gamma2.6|gamma2.8prophoto|pq|hlg|v-log|s-log1|s-log2>



#vf-append =hqdn3d


 ########
 # 字幕 #
 ########


#sub-auto                       = fuzzy
 sub-auto                       =  exact   
 # <no|默认exact|fuzzy|all> 自动加载当前播放文件的同名外挂字幕（fuzzy为模糊名，exact为精确名）
sub-file-paths                 = storage/sdcard1/Fonts;ttf;sub;subtitles;字幕;C:/字幕库
# 在指定的额外目录中寻找匹配的字幕。支持相对和绝对路径，示例即自动搜索当前文件路径下名为"sub","subtitles","字幕"和C盘的"字幕库"文件夹内
 slang                          = chs,sc,zh,chi,zho
                                              # 字幕首选语言为中文，但MPV优先加载外挂轨道，此项参数可能实际用处不大
blend-subtitles                = yes
#blend-subtitles                = video       
# <yes|video|默认no> 在插值和颜色管理之前，将字幕混合到视频帧上。
#video类似于yes，但是会以视频的原始分辨率绘制字幕，并与视频一起缩放，即会受着色器、缩放器、时间插值、色彩管理的影响
#建议yes。
                                              
# 启用此功能会将字幕限制在视频的可见部分（不能出现在视频下方的黑色空白处）
# 还会让字幕受 --icc-profile --target-prim --target-trc --interpolation --gamma-factor --glsl-shaders 的影响
                                              
# 与 --interpolation 一起使用时，可提高字幕渲染性能

##⇘⇘纯文本字幕部分 —— SRT LRC

#sub-font                       = "/storage/emulated/0/Fonts/LXGWWenKai-Regular.ttf"
# 指定纯文本字幕的默认字体
# 该参数本应对ASS字幕无效，但实际影响了ASS的后备字体 https://github.com/mpv-player/mpv/issues/8637
 sub-back-color                 = "#641C1C1C" 
 # <格式为(AA)RRGGBB> 设定纯文本字幕的背景色
#sub-use-margins                = no          
# 是否使纯文本字幕输出在黑边上，默认 yes

#profile                        = sub_SRT     
# 备选的纯文本字幕样式方案，具体参数见 "profiles.conf" 中的同名配置预设

#secondary-sub-ass-override=yes
#mpv渲染ASS次字幕时默认剥离所有效果以类似SRT的方式渲染，在 mpv.conf 中更改此参数可使其的渲染行为贴合主字幕。
#报错
#secondary-sub-pos=100
#mpv默认将次字幕置于顶部输出，更改此参数可恢复预设位置。
#报错

##⇘⇘高级字幕部分 —— SSA ASS

#sub-ass-override               = force       
# <no|默认 yes|scale|force|strip> 是否覆盖字幕脚本的原始样式，默认只应用 --sub-ass-* 类的选项
# scale 在此基础上也应用了 --sub-scale ， force 更进一步应用所有 --sub-* 的选项， strip 则剥离全部标记和样式
sub-ass-scale-with-window      = no         
# 字幕随窗口缩放而不是随视频缩放，默认 no
embeddedfonts                  = yes          
# 是否使用mkv容器的内嵌字体，默认 yes
 sub-ass-force-margins          = yes         
 # [当 --blend-subtitles=yes/video 时无效] 使ASS字幕尽可能输出在黑边上
#sub-ass-force-style            = Fontname=/storage/emulated/0/Fonts/LXGWWenKai-Regular.ttf                                             
# 使用自定义的参数以覆盖字幕文件内的预设。示例：覆盖字幕内的所有字体

##⇘⇘模拟vsfilter相关
##默认情况下libass和vsfilter渲染的字幕存在部分差异，以下选项可用于使视觉效果相近（模仿vsfilter）

sub-ass-vsfilter-aspect-compat = yes          
# 播放非常规比例视频时拉伸ASS字幕，默认 yes
sub-ass-vsfilter-blur-compat   = no          
# 通过视频分辨率而不是.ass指定的分辨率缩放"\blur"标签，默认 yes
sub-ass-vsfilter-color-compat  = full        
# <默认basic|full|force-601|no> 字幕色彩空间处理


##⇘⇘图形字幕部分 —— IDX SUB SUP

stretch-image-subs-to-screen   = no         
# 拉伸图形字幕到缩放分辨率而不是参考视频分辨率，可以使PGS实现输出在黑边的效果，可能破坏显示效果。默认 no
image-subs-video-resolution    = no         
# 使用视频分辨率覆盖图形字幕的原始分辨率，默认 no



 ########
 # 截图 #
 ########
##⇘⇘以下预设参数是为了截取高质量的图片（输出质量越高，截图处理效率越低）

 screenshot-format             = png  
 # <默认 jpg|(同前)jpeg|png|webp|jxl>

# screenshot-jpeg-quality       = 100  
 # <0-100> JPEG的质量，默认 90
# screenshot-jpeg-source-chroma = no   
 # 用与源视频相同的色度半采样写入JPEG，默认 yes
 screenshot-png-compression    = 5    
 # <0-9> PNG压缩等级，过高的等级影响性能，默认 7
#此值越大，截图文件越小，但性能消耗更高，需要更长的时间保存截图
screenshot-png-filter         = 5    
# <0-5> PNG的压缩过滤器。默认值 5 即可实现最佳压缩率
 screenshot-webp-lossless      = yes  
 # 无损WEBP，默认 no
 screenshot-webp-quality       = 75  
 # <0-100> [当 --screenshot-webp-lossless=no 时生效] 有损WEBP的质量，默认 75
 screenshot-webp-compression   = 3    
 # <0-6> WEBP压缩等级，使用有损WEBP时进一步降低图片质量，默认 4
 screenshot-jxl-distance       = 0    
 # <0-15> JXL的视觉模型距离，0为质量无损，0.1为视觉无损，默认值 1 相当于JPEG的90质量
 screenshot-jxl-effort         = 5    
 # <1-9> JXL压缩等级，过高的等级影响性能，默认 3

screenshot-tag-colorspace     = yes  
# 使用适当的色彩空间标记屏幕截图（并非所有格式受支持）默认 no
screenshot-high-bit-depth     = no  
#
screenshot-high-bit-depth     = yes  
# 主要影响PNG/JXL，尽可能使用和视频输出时近似的位深，默认 yes
 
#screenshot-template           = "~~/screenshot/MPV-%P-N%n"
#
screenshot-template           = %f_%P-%F_%H_%M_%S
#上一行报错“fixed-length quoting expected - put "quotes" around the option value if you did not intend to use this, but your option value starts with '%'”不用管
#在 reex 中不能加引号，加引号会不能截屏，报“Invalid screenshot filename template! Fix or remove the --screenshot-template option.”即“屏幕截图文件名模板无效！请修复或删除 --screenshot-template 选项。”
# 截图命名模板： https://mpv.io/manual/master/#options-screenshot-template
#妥协之计，需要在 reex 添加一个按钮的截屏，名称随意，命令为 screenshot ，且仅能保存在 /storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv 下，下面保存路径即为/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/screenshot/下，且需要 root 权限才能移动复制截图
#若无必要，还是推荐使用reex内置的截图按钮截图
#screenshot-directory          = "~~desktop/"
#
screenshot-dir= "~~/screenshot/"
                                      
# [若已在截图命名模板中设置路径，此时无需使用该参数 ] 保存截图在桌面