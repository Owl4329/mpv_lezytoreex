[FHD]
profile-desc=1080p
profile-restore=copy
profile-cond= (width==1920 and height==1080) or (width==1920 and height<1081) or (height==1080 and width<1921)
#vf-add=rotate=90*PI/180
#video-rotate=90
#画面顺时针转90°

include = "/storage/emulated/0/Android/data/xyz.re.player.ex/files/mpv/profiles/self-adaptive_deband.conf"

########
##⇘⇘音视频同步模式。只需注释掉 --video-sync 即可恢复MPV的默认同步模式
########




# video-sync                  =desync
#同步视频到系统时钟，并让音频自行播放。
# video-sync                  = audio
# 默认值 audio（与音频/系统时钟同步）通常兼容性最好但有偶尔的丢帧和重复
#将视频帧计时到音频。这是最稳健的模式，因为播放器不需要对显示器的行为进行任何假设。缺点是它可能会导致偶尔的丢帧或重复。如果音频被禁用，这将使用系统时钟。这是默认模式。

 #video-sync                  = display-resample  
 #对音频重新采样以匹配视频。这种模式也将尝试调整音频速度来补偿其它漂移（这表示它将每隔一段时间以不同的速度播放音频，以减少A/V差异）。
 
#video-sync                  =display-resample-vdrop
#重新采样音频以匹配视频。丢弃视频帧以补偿漂移。

# video-sync                  =display-resample-desync
#与之前的模式一样，但没有A/V补偿。

# video-sync                  =display-vdrop
#丢弃或重复视频帧，以补偿不同步的视频（虽然它应该有与 audio 相同的效果，但实现却非常不同）。

# video-sync                  =display-adrop
#丢弃或重复音频数据以补偿不同步的视频。如果真实的显示器刷新率与报告的或强制的刷新率相差太大，这种模式将引起严重的音频瑕疵。从mpv0.33.0开始，这个模式作用于整全部音频帧，而不是单个采样。

# video-sync                  =display-desync
#同步视频到显示，并让音频自行播放。
 interpolation               = yes
# interpolation               = no
  tscale                      = mitchell  
          
 # [仅当 --interpolation=yes 时生效] 时间插值算法（帧混合，非光流法）
  #常见的 --tscale 选择包括 oversample, linear, catmull_rom, mitchell, gaussian, 或 bicubic 。这些都是按照平滑度/模糊度递增的顺序排列的， bicubic 是最平滑/最模糊的，而 oversample 是最清晰/最不平滑的。                                        
# 追求原始观感可以使用 oversample（效果类似MADVR的smoothmotion），默认 mitchell

 video-sync-max-factor=5
#尝试将视频的FPS与显示的FPS相匹配的最大倍数（默认： 5）

#fps=fps=60/1.01


#scaler-lut-size=10
#设置缩放器kernels的查找纹理的大小（默认： 6）。纹理的实际大小是 2^N ，选项值为 N <6——10>。查找纹理使用64、128、256、512、1024采样。
#所有的权重都是从这些采样中线性插值出来的，所以增加查找表的大小可能会改善缩放器的精度。
#报错
#cscale                      = lanczos
#cscale                      = spline64

#cscale                      = ewa_lanczos
#cscale                      = ewa_lanczossharp
#cscale-cutoff=0.0524
#一旦数值范围下降到这个阈值以下，就提前切断filter的kernel。这样做可以通过忽略LUT中被window函数有效归零的部分，更积极地修剪可跳过的系数。只影响polar (EWA) filter。默认是0.001，这在感知上是透明的，但可以提供10%-20%的加速，取决于所选择的确切半径和filter kernel。



#glsl-shaders-append  = "~~/shaders/Anime4K_Clamp_Highlights.glsl"
#主要用于钳制画面的高光，抗振铃和减少过冲。
#该着色器放在所有后处理着色器之前或（推荐）之后。
#glsl-shaders-append = "~~/shaders/Anime4K_Restore_CNN_S.glsl"
#线条重建系列，开发者推荐在upscale之前使用，减少上采样后产生的伪影。
#glsl-shaders-append = "~~/shaders/Anime4K_Thin_Fast.glsl"
#线条加深、变细系列
#glsl-shaders-append = "~~/shaders/Anime4K_Deblur_Original.glsl"
#去模糊系列：避免过冲和振铃的情况下锐化细节

#glsl-shaders-append = "~~/shaders/LumaSharpen.glsl"
#亮度通道的锐化
#glsl-shaders-append  = "~~/shaders/adaptive_sharpen_luma.glsl"
 #自适应锐化，变体 best 理论上拥有最佳质量但强度较低；变体 luma 只处理亮度通道不适合rgb源
 
#glsl-shaders-append  = "~~/shaders/AMD_CAS_rgb.glsl"
#移植自AMD FidelityFX CAS (Contrast Adaptive Sharpening)，原始设计用于游戏，对比度自适应锐化是一种低开销的锐化算法。
#glsl-shaders-append  = "~~/shaders/AMD_FSR_rgb.glsl"
#移植自AMD FidelityFX Super Resolution (FSR)，原始设计用于游戏，是一种先执行常规放大后再进行对比度自适应锐化的改良算法。放大部分基于lanczos+bilinear，锐化部分基于cas

#glsl-shaders-append = "~~/shaders/noise_static_luma.glsl"
#glsl-shaders-append = "~~/shaders/noise_static_chroma.glsl"
#优化静态的亮度/色度噪点。